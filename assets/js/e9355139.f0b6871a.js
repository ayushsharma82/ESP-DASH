"use strict";(self.webpackChunkesp_dash_docs=self.webpackChunkesp_dash_docs||[]).push([[611],{5680:(e,r,a)=>{a.d(r,{xA:()=>s,yg:()=>h});var n=a(6540);function t(e,r,a){return r in e?Object.defineProperty(e,r,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[r]=a,e}function o(e,r){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var r=1;r<arguments.length;r++){var a=null!=arguments[r]?arguments[r]:{};r%2?o(Object(a),!0).forEach((function(r){t(e,r,a[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(a,r))}))}return e}function l(e,r){if(null==e)return{};var a,n,t=function(e,r){if(null==e)return{};var a,n,t={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],r.indexOf(a)>=0||(t[a]=e[a]);return t}(e,r);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],r.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(t[a]=e[a])}return t}var c=n.createContext({}),p=function(e){var r=n.useContext(c),a=r;return e&&(a="function"==typeof e?e(r):i(i({},r),e)),a},s=function(e){var r=p(e.components);return n.createElement(c.Provider,{value:r},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var r=e.children;return n.createElement(n.Fragment,{},r)}},g=n.forwardRef((function(e,r){var a=e.components,t=e.mdxType,o=e.originalType,c=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),d=p(a),g=t,h=d["".concat(c,".").concat(g)]||d[g]||u[g]||o;return a?n.createElement(h,i(i({ref:r},s),{},{components:a})):n.createElement(h,i({ref:r},s))}));function h(e,r){var a=arguments,t=r&&r.mdxType;if("string"==typeof e||t){var o=a.length,i=new Array(o);i[0]=g;var l={};for(var c in r)hasOwnProperty.call(r,c)&&(l[c]=r[c]);l.originalType=e,l[d]="string"==typeof e?e:t,i[1]=l;for(var p=2;p<o;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}g.displayName="MDXCreateElement"},4796:(e,r,a)=>{a.r(r),a.d(r,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var n=a(8168),t=(a(6540),a(5680));const o={title:"Color Picker Card",sidebar_label:"Color Picker (Pro)",sidebar_position:16},i=void 0,l={unversionedId:"widgets/cards/color-picker",id:"version-v4.x.x/widgets/cards/color-picker",title:"Color Picker Card",description:"This is an exclusive feature of DASH Pro. Check it out here.",source:"@site/versioned_docs/version-v4.x.x/widgets/cards/color-picker.md",sourceDirName:"widgets/cards",slug:"/widgets/cards/color-picker",permalink:"/widgets/cards/color-picker",draft:!1,tags:[],version:"v4.x.x",sidebarPosition:16,frontMatter:{title:"Color Picker Card",sidebar_label:"Color Picker (Pro)",sidebar_position:16},sidebar:"tutorialSidebar",previous:{title:"Week Selector (Pro)",permalink:"/widgets/cards/week-selector"},next:{title:"Joystick (Pro)",permalink:"/widgets/cards/joystick"}},c={},p=[{value:"Initializer",id:"initializer",level:3},{value:"Callback",id:"callback",level:3},{value:"Updater",id:"updater",level:3},{value:"Reference",id:"reference",level:3}],s={toc:p},d="wrapper";function u(e){let{components:r,...a}=e;return(0,t.yg)(d,(0,n.A)({},s,a,{components:r,mdxType:"MDXLayout"}),(0,t.yg)("admonition",{title:"Pro Feature",type:"danger"},(0,t.yg)("p",{parentName:"admonition"},"This is an exclusive feature of DASH Pro. Check it out ",(0,t.yg)("a",{parentName:"p",href:"https://espdash.pro"},"here"),".")),(0,t.yg)("img",{className:"card-preview",src:"/img/v4/color-picker.png",width:"280px",alt:"Color Picker Card Preview"}),(0,t.yg)("br",null),(0,t.yg)("br",null),(0,t.yg)("p",null,"With color picker card, you have an option to take an color input from user. This is particularly useful if you want to have an input for LED color, display color etc. Color picker card will return an ",(0,t.yg)("inlineCode",{parentName:"p"},"hex")," string of color selected by user. "),(0,t.yg)("p",null,"A bit more info on ",(0,t.yg)("inlineCode",{parentName:"p"},"hex")," color values if you are not familiar with it: ",(0,t.yg)("a",{parentName:"p",href:"https://www.w3schools.com/html/html_colors_hex.asp"},"W3Schools Article")),(0,t.yg)("h3",{id:"initializer"},"Initializer"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-cpp"},'/* \n  Color Picker Card\n  Valid Arguments: (ESPDash dashboard, Card Type, const char* name)\n*/\nCard card1(&dashboard, COLOR_PICKER_CARD, "Color Picker");\n')),(0,t.yg)("h3",{id:"callback"},"Callback"),(0,t.yg)("p",null,"Color picker card requires a callback function which will be called when we receive a input from our dashboard. In our setup block, we will be calling our ",(0,t.yg)("inlineCode",{parentName:"p"},"attachCallback")," function and provide a lambda (callback) function with a ",(0,t.yg)("inlineCode",{parentName:"p"},"const char*")," (character array) argument. Whenever a user selects a color, this callback will be triggered with ",(0,t.yg)("inlineCode",{parentName:"p"},"hex")," value of color."),(0,t.yg)("p",null,(0,t.yg)("strong",{parentName:"p"},"Note:")," You need to call the ",(0,t.yg)("inlineCode",{parentName:"p"},"update")," function and ",(0,t.yg)("inlineCode",{parentName:"p"},"sendUpdates")," immediately once you receive the value in callback. Otherwise user input will not be registered on dashboard and it will keep the card stuck in 'waiting' phase."),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-cpp"},'/*\n  We provide our attachCallback with a lambda function to handle incomming data\n  Example Value: mon,tue,wed,thu,fri,sat,sun\n*/\ncard1.attachCallback([&](const char* hex){\n  Serial.println("[Card1] Color Picker Triggered: "+String(hex));\n  card1.update(value);\n  dashboard.sendUpdates();\n});\n')),(0,t.yg)("h3",{id:"updater"},"Updater"),(0,t.yg)("p",null,"You can also update the value inside color picker card using the same hex formula."),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-cpp"},"card1.update(const char* value);\n")),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-cpp"},"card1.update(String value);\n")),(0,t.yg)("h3",{id:"reference"},"Reference"),(0,t.yg)("p",null,"This is a reference sketch showing positions for intializer, callback and updater."),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-cpp"},'\n...\n\n/* Color picker card initializer */\nCard colorpicker(&dashboard, COLOR_PICKER_CARD, "Color Picker 1");\n\n\nvoid setup() {\n  ...\n\n  /* Color picker callback */\n  colorpicker.attachCallback([&](const char* hex){\n    Serial.println("Color picker callback triggered: "+String(hex));\n    /* Color picker card updater - you need to update the color picker with latest value upon firing of callback */\n    colorpicker.update(value);\n    /* Send update to dashboard */\n    dashboard.sendUpdates();\n  });\n}\n\nvoid loop() {\n  ...\n}\n\n')))}u.isMDXComponent=!0}}]);